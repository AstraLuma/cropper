#!/usr/bin/python -O
#-*- coding: utf-8 -*-
"""
cropper [file]

An app to easily crop an image into multiple pieces.
"""
#TODO: Add preferences:
# * List of box colors
# * Alpha level
# * Allow overlapping?
# * Outside box handling: Disallow (bound), Ignore, Pad
#TODO: Add file drag&drop
from __future__ import with_statement, division, absolute_import
import gtk, gobject
#gtk.gdk.threads_init()
#gobject.threads_init()
import pango
try:
	import gnomevfs
except ImportError:
	gnomevfs = None
else:
	import gnomevfs.async
from gbuilder import BuilderWindow, resource
from box import Box
from boxmodel import BoxListStore
from imagespace import ImageSpace
from optparse import OptionParser
#from gobject.option import OptionParser # the args returned is just wrong
import sys, os, subprocess
from vfsutils import make_absolute
parser = OptionParser()
#parser.add_option("-f", "--file", dest="filename",
#                  help="write report to FILE", metavar="FILE")
#parser.add_option("-q", "--quiet",
#                  action="store_false", dest="verbose", default=True,
#                  help="don't print status messages to stdout")

if gnomevfs:
	BUFSIZE = 8*1024 #8K # Amount to read in one go
else:
	BUFSIZE = 16*1024 #16K

def permIter(seq):
	"""
	Given some sequence 'seq', returns an iterator that gives
	all permutations of that sequence.
	"""
	# http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/105962
	## Base case
	if len(seq) == 1:
		yield seq[0]
	else:
		## Inductive case
		for i in range(len(seq)):
			element_slice = seq[i:i+1]
			rest_iter = permIter(seq[:i] + seq[i+1:])
			for rest in rest_iter:
				yield element_slice + rest

class Cropper(BuilderWindow):
	window = property(lambda self: self.wCropper)
	filename = None
	def __init__(self, options, args, *pargs, **kwargs):
		print 'Cropper.__init__()'
		#TODO: Put all of this into GtkBuilder
		self.model = BoxListStore()
		self.model.exist_image = 'filesave'
		self.model.no_exist_image = 'filenew'
		
		self.tvAreas.set_model(self.model)
		self.tvAreas.get_selection().set_mode(gtk.SELECTION_MULTIPLE)
		self.tvAreas.get_selection().connect('changed', self.on_selection_changed)
		
		self.isImage = ImageSpace(model=self.model, box=1)
		self.isImage.selection = self.tvAreas.get_selection()
		self.isImage.mode = ImageSpace.INSERT
		self.isImage.next_color = gtk.gdk.color_parse('#A0F')
		self.isImage.connect('box-added', self.on_box_added)
#		self.isImage.connect('insert-box-changed', self.on_insert_box_changed)
		self.swImage.add(self.isImage)
		
		self.crpExists = gtk.CellRendererPixbuf()
		self.crtFilename = gtk.CellRendererText()
		self.crtColor = gtk.CellRendererText()
		self.crtColor.set_property('background-set', True)
		self.crtColor.set_property('text', ' ')
		
		self.tvcFile = gtk.TreeViewColumn()
		self.tvcFile.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
		self.tvcFile.pack_start(self.crpExists, False)
		self.tvcFile.set_attributes(self.crpExists, icon_name=10)
		self.tvcFile.pack_start(self.crtFilename, True)
		self.tvcFile.set_attributes(self.crtFilename, text=2)
		self.tvcColor = gtk.TreeViewColumn()
		self.tvcColor.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
		self.tvcColor.pack_start(self.crtColor, True)
		self.tvcColor.set_attributes(self.crtColor, background_gdk=8)
		
		self.tvAreas.append_column(self.tvcFile)
		self.tvAreas.append_column(self.tvcColor)
		self.tvAreas.set_headers_visible(False)
		self.tvAreas.set_tooltip_column(11)
		
		if len(args):
			print "args: %r" % args
			self.Open(None, file=make_absolute(args[0]))
#		self.window.connect('key-press-event', self._keypress)
	
#	def _keypress(self, window, event):
#		print "Keypress: %r %r" % (event.keyval, event.state)
#		return False
	
	def present(self):
#		self.preshow()
		self.wCropper.show_all()
		self.wCropper.present()
	
	def add_box(self, fn, box, color=None):
		if color is not None:
			if isinstance(color, basestring):
				color = gtk.gdk.color_parse(color)
			if not isinstance(box, gtk.gdk.Rectangle):
				box = gtk.gdk.Rectangle(*box)
			box = Box(box, color)
		self.model.append([fn, box])
	
	def get_next_filename(self):
		# TODO: When we have the filename, turn it into a conglamoratation
		if self.filename is None:
			return ''
		before, after = os.path.splitext(self.filename)
		return '%s.%i%s' % (before, len(self.model), after)
	
	_color_iter = None
	def get_next_color(self, color):
		if self._color_iter is None:
			self._color_iter = (gtk.gdk.color_parse('#'+p) for p in permIter('F0A'))
		try:
			return self._color_iter.next()
		except StopIteration:
			self._color_iter = None
			return self.get_next_color(color)
	
	# Event handlers
	def on_delete_event(self, widget, event):
		gtk.main_quit()
	
	def on_box_added(self, widget, box):
		self.model.append([self.get_next_filename(), box])
		self.isImage.next_color = self.get_next_color(self.isImage.next_color)
	
	def on_selection_changed(self, selection):
		self.actions['Delete'].set_sensitive(bool(selection.count_selected_rows()))
	
	# Actions/UI stuff
	PROPS = 'expand', 'fill', 'padding', 'pack-type', 'position'
	def add_menubar(self, menubar):
		props = self.vbContent.child_get(self.mbMenu, *self.PROPS)
		self.vbContent.remove(self.mbMenu)
		self.mbMenu = menubar
		params = []
		for k,v in zip(self.PROPS, props):
			params += [k,v]
		self.vbContent.add_with_properties(self.mbMenu, *params)
	
	def add_toolbar(self, toolbar):
		props = self.vbContent.child_get(self.tbTools, *self.PROPS)
		self.vbContent.remove(self.tbTools)
		self.tbTools = toolbar
		params = []
		for k,v in zip(self.PROPS, props):
			params += [k,v]
		self.vbContent.add_with_properties(self.tbTools, *params)

#########
# ACTIONS
#########
	
	def Open(self, action, **kwargs):
		print 'Open'
		
		if 'file' in kwargs:
			filename = kwargs['file']
		else:
			dlg = gtk.FileChooserDialog(parent=self.wCropper,
				action=gtk.FILE_CHOOSER_ACTION_OPEN, 
				buttons=(
					gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
					gtk.STOCK_OPEN, gtk.RESPONSE_OK,
					)
				)
			dlg.set_use_preview_label(True)
			dlg.set_select_multiple(False)
			dlg.set_local_only(gnomevfs is None)
			if dlg.run() in (gtk.RESPONSE_CANCEL, gtk.RESPONSE_NONE):
				dlg.destroy()
				return
			if gnomevfs is None:
				filename = dlg.get_filename()
			else:
				filename = dlg.get_uri()
			dlg.destroy()
		
		# Open image
		self.model.clear()
		self.filename = filename
		#self.isImage.image = gtk.gdk.pixbuf_new_from_file(filename)
		#Use gtk.gdk.PixbufLoader
		# open the file
		pbl = gtk.gdk.PixbufLoader()
		self.isImage.loadfrompixbuf(pbl)
		if gnomevfs is None:
			img = open(filename, 'r')
			def readchunk(cb, size, f, pbl):
				data = f.read(size)
				if len(data) > 0:
					pbl.write(data)
					gobject.idle_add(cb, size, f, pbl)
				else:
					pbl.close()
			gobject.idle_add(readchunk, readchunk, BUFSIZE, img, pbl)
		else:
			self._loadfromvfs(pbl, gnomevfs.URI(filename))
	
	def _loadfromvfs(self, pbl, uri):
		if not gnomevfs.exists(uri):
			raise IOError, "File does not exist"
		# Handles all the async mess. I want twisted deferreds!
		def _open(img, exc_type):
			if exc_type:
				pbl.close()
			else:
				def _read(img, buffer, exc_type, bytes_requested):
					if exc_type:
						pbl.close()
					else:
						img.read(BUFSIZE, _read) # Start the next read immediately
						try:
							pbl.write(buffer)
						except:
							pbl.close()
							img.cancel()
							raise
				img.read(BUFSIZE, _read)
		img = gnomevfs.async.open(uri, _open, gnomevfs.OPEN_READ)
	
	def Crop(self, action):
		mktemp = lambda fn:os.path.join('/tmp', os.path.basename(fn))
		print 'Crop'
		# Copy from remote to local
		#FIXME: Better feedback when using gnomevfs
		fname = None
		def _copyhere_cb(_, info, data):
			if info.phase == gnomevfs.XFER_PHASE_COMPLETED:
				_copyhere()
			return True
		def _copyhere():
			cmd_start = ['convert', fname]
			#FIXME: Ask if there's conflicts
			for fn, box in ((r[0],r[1]) for r in self.model):
				print "fn:", fn
				if gnomevfs is not None:
					# fn is a gnomevfs URI, make tmp file
					uri = fn
					fn = mktemp(fn)
				#FIXME: Limit to image size
				r= box.rect
				cmd = cmd_start+['-crop', '%ix%i+%i+%i' % (r.width, r.height, r.x, r.y), fn]
				print "cmd:", cmd
				try:
					subprocess.check_call(cmd)
				except:
					print >> sys.stderr, "Error executing command %r:" % cmd
					import traceback
					traceback.print_exc()
			if gnomevfs is not None:
				print "Copy back"
				gnomevfs.async.xfer(
					source_uri_list=[gnomevfs.URI(mktemp(r[0])) for r in self.model], 
					target_uri_list=[gnomevfs.URI(r[0]) for r in self.model],
					xfer_options=gnomevfs.XFER_DEFAULT,
					error_mode=gnomevfs.XFER_ERROR_MODE_ABORT,
					overwrite_mode=gnomevfs.XFER_OVERWRITE_MODE_REPLACE,
					progress_update_callback=(lambda _, info, data: True),
					update_callback_data=None,
#					progress_sync_callback=(lambda info, data: True),
#	`				sync_callback_data=0x1234,
					)
			# Update the model
			self.model.foreach(BoxListStore.row_changed)
		if gnomevfs is None:
			fname = self.filename
			_copyhere()
		else:
			fname = mktemp(self.filename)
			gnomevfs.async.xfer(
				source_uri_list=[gnomevfs.URI(self.filename)], 
				target_uri_list=[gnomevfs.URI(fname)],
				xfer_options=gnomevfs.XFER_DEFAULT,
				error_mode=gnomevfs.XFER_ERROR_MODE_ABORT,
				overwrite_mode=gnomevfs.XFER_OVERWRITE_MODE_REPLACE,
				progress_update_callback=_copyhere_cb,
				update_callback_data=None,
#				progress_sync_callback=(lambda info, data: True),
#				sync_callback_data=0x1234,
				)
	
	def Quit(self, action):
		self.wCropper.destroy()
	
	def Clear(self, action):
		print 'Clear'
		self.model.clear()
	
	def Cut(self, action):
		print 'Cut'
		pass
	
	def Copy(self, action):
		print 'Copy'
		pass
	
	def Paste(self, action):
		print 'Paste'
		pass
	
	def Delete(self, action):
		print 'Delete'
		model, rows = self.tvAreas.get_selection().get_selected_rows()
		rows = map(model.get_iter, rows)
		for row in rows:
			model.remove(row)
	
	def SelectAll(self, action):
		self.tvAreas.get_selection().select_all()
	
	def ZoomIn(self, action):
		self.isImage.zoom *= 1.1
	
	def ZoomOut(self, action):
		self.isImage.zoom /= 1.1
	
	def ZoomNormal(self, action):
		self.isImage.zoom = 1.0
	
	def ZoomFit(self, action):
		print "ZoomFit"
		self.isImage.zoom_to_size()
	
	def FlipHorizontal(self, action):
		pass
	
	def FlipVertical(self, action):
		pass
	
	def RotateCW(self, action):
		pass
	
	def RotateCCW(self, action):
		pass
	
	def EditPreferences(self, action):
		pass
	
	def AutoShrink(self, action):
		# Shrink boxes to image size
		pass
	
	def About(self, action):
		dlg = gtk.AboutDialog()
		props = {
#			'version': """$Revision: 104 $""",
			'name': 'cropper',
			'logo-icon-name': 'image',
			'authors': ['James Bliss <james.bliss@astro73.com>'],
			'copyright': u'\N{COPYRIGHT SIGN} 2008 James Bliss',
			'website': 'http://www.astro73.com/'
			}
		for k,v in props.iteritems():
			dlg.set_property(k,v)
		dlg.run()
		dlg.destroy()
	
	def Add(self, action, value):
		if action == value:
			print "Add"
			self.isImage.mode = ImageSpace.INSERT
	
	def Select(self, action, value):
		if action == value:
			print "Select"
			self.isImage.mode = ImageSpace.SELECT

if __name__ == '__main__':
	options, args = parser.parse_args(sys.argv[1:])
	app = Cropper(fname=resource('cropper.xml'), options=options, args=args)
	
#	app.add_box('test1.gif', ( 75,131,354,547), '#F0A')
#	app.add_box('test2.gif', ( 15, 22,467,191), '#AF0')
#	app.add_box('test3.gif', (273, 37,204,712), '#0AF')
#	app.add_box('test4.gif', ( 18,622,470,124), '#0F0')
#	app.add_box('test5.gif', ( 11, 20,178,722), '#00F')
#	app.isImage.image = gtk.gdk.pixbuf_new_from_file('test.gif')
#	app.isImage.mode = ImageSpace.INSERT
	
#	app.wCropper.set_default_size(700, 1000)
	
	# Run
	app.present()
	print "Model data:", map(tuple, app.model)
	gtk.gdk.set_show_events(True)
	gtk.main()
